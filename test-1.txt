from fastapi import FastAPI, Query, HTTPException
from yt_dlp import YoutubeDL
import yt_dlp
import uvicorn 

app = FastAPI()

class MusicSearcher:
    def __init__(self):
        pass
    
    def format_duration_fast(self, duration):
        """Format duration in seconds to MM:SS or HH:MM:SS format"""
        if not duration or duration <= 0:
            return "0:00"
        
        hours = int(duration // 3600)
        minutes = int((duration % 3600) // 60)
        seconds = int(duration % 60)
        
        if hours > 0:
            return f"{hours}:{minutes:02d}:{seconds:02d}"
        else:
            return f"{minutes}:{seconds:02d}"
    
    def format_views_fast(self, view_count):
        """Format view count to human readable format"""
        if not view_count:
            return "0 views"
        
        if view_count >= 1_000_000_000:
            return f"{view_count / 1_000_000_000:.1f}B views"
        elif view_count >= 1_000_000:
            return f"{view_count / 1_000_000:.1f}M views"
        elif view_count >= 1_000:
            return f"{view_count / 1_000:.1f}K views"
        else:
            return f"{view_count} views"
    
    def perform_search(self, query, offset=0, exclude_ids=None, batch_size=10):
        """Perform the actual search using yt-dlp - now supports pagination and exclusion."""
        if not query:
            return []
        
        if exclude_ids is None:
            exclude_ids = set()
        else:
            exclude_ids = set(exclude_ids)
        
        try:
            print(f"Searching for: {query} (offset={offset}, exclude={len(exclude_ids)})")
            
            # Streamlined yt-dlp options for speed - based on your working code
            search_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'skip_download': True,
                'ignoreerrors': True,
                'geo_bypass': True,
                'noplaylist': True,
                'socket_timeout': 8,
                'retries': 1,
                'format': 'best',
            }
            
            # Fetch more results than needed to allow for exclusion
            fetch_count = max(batch_size * 2, 30)
            
            with yt_dlp.YoutubeDL(search_opts) as ydl:
                search_results = ydl.extract_info(
                    f"ytsearch{fetch_count + offset}:{query}",
                    download=False
                )
            
            print(f"yt-dlp response received")
            
            if not search_results or 'entries' not in search_results:
                print("No entries in search results")
                return []
            
            entries = search_results.get('entries', [])
            
            # Skip offset and filter out excluded IDs
            filtered = []
            seen = set()
            
            for entry in entries[offset:]:
                if not entry or not entry.get('id'):
                    continue
                
                vid = entry['id']
                if vid in exclude_ids or vid in seen:
                    continue
                
                seen.add(vid)
                title = entry.get('title', 'No Title')
                uploader = entry.get('uploader', 'Unknown')
                duration = entry.get('duration')
                view_count = entry.get('view_count')
                
                # Skip if title and uploader are the same (after case-insensitive comparison)
                if str(title).strip().lower() == str(uploader).strip().lower():
                    continue
                
                # Skip if duration is 0 or invalid
                if not duration or duration <= 0:
                    continue
                
                result = {
                    'title': str(title).strip()[:100],
                    'thumbnail_url': f"https://img.youtube.com/vi/{vid}/mqdefault.jpg",
                    'videoId': vid,
                    'uploader': str(uploader).strip()[:50] if uploader else 'Unknown',
                    'duration': self.format_duration_fast(duration),
                    'view_count': self.format_views_fast(view_count),
                    'url': f"https://www.youtube.com/watch?v={vid}"
                }
                filtered.append(result)
                
                if len(filtered) >= batch_size:
                    break
            
            print(f"Processed {len(filtered)} results (offset={offset})")
            return filtered
            
        except Exception as e:
            print(f"yt-dlp search failed: {str(e)}")
            return []
    
    def get_stream_info(self, video_id_or_url):
        """Get streaming URL for a video"""
        try:
            # More robust options for stream extraction
            stream_opts = {
                'format': 'bestaudio/best',
                'quiet': True,
                'no_warnings': True,
                'ignoreerrors': True,
                'geo_bypass': True,
                'socket_timeout': 10,
                'retries': 2,
            }
            
            # Handle both video IDs and full URLs
            if not video_id_or_url.startswith('http'):
                url = f"https://www.youtube.com/watch?v={video_id_or_url}"
            else:
                url = video_id_or_url
            
            with yt_dlp.YoutubeDL(stream_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                
                if not info:
                    return None
                
                # Get the best audio format
                formats = info.get('formats', [])
                audio_url = None
                
                # Try to find the best audio-only format
                for fmt in formats:
                    if (fmt.get('acodec') != 'none' and 
                        fmt.get('vcodec') == 'none' and
                        fmt.get('url')):
                        audio_url = fmt.get('url')
                        break
                
                # Fallback to any format with audio
                if not audio_url:
                    for fmt in formats:
                        if fmt.get('acodec') != 'none' and fmt.get('url'):
                            audio_url = fmt.get('url')
                            break
                
                if not audio_url:
                    return None
                
                return {
                    'title': info.get('title'),
                    'url': audio_url,
                    'duration': self.format_duration_fast(info.get('duration')),
                    'uploader': info.get('uploader'),
                    'thumbnail': info.get('thumbnail'),
                    'view_count': self.format_views_fast(info.get('view_count'))
                }
                
        except Exception as e:
            print(f"Stream extraction failed: {str(e)}")
            return None

# Create global searcher instance
searcher = MusicSearcher()

@app.get("/search")
def search_music(
    query: str = Query(..., description="Search query for music"),
    offset: int = Query(0, description="Offset for pagination", ge=0),
    batch_size: int = Query(10, description="Number of results to return", ge=1, le=50),
    exclude_ids: str = Query("", description="Comma-separated video IDs to exclude")
):
    """Search for music using the working yt-dlp approach"""
    try:
        # Parse exclude_ids
        excluded = []
        if exclude_ids:
            excluded = [vid.strip() for vid in exclude_ids.split(',') if vid.strip()]
        
        results = searcher.perform_search(
            query=query,
            offset=offset,
            exclude_ids=excluded,
            batch_size=batch_size
        )
        
        return {
            "results": results,
            "query": query,
            "offset": offset,
            "batch_size": batch_size,
            "count": len(results)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Search failed: {str(e)}")

@app.get("/stream")
def stream_music(
    video_id: str = Query(..., description="YouTube video ID or full URL")
):
    """Get streaming URL for a video"""
    try:
        stream_info = searcher.get_stream_info(video_id)
        
        if not stream_info:
            raise HTTPException(status_code=404, detail="Stream not found or unavailable")
        
        return stream_info
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Stream extraction failed: {str(e)}")

@app.get("/stream/{video_id}")
def stream_music_path(video_id: str):
    """Alternative endpoint with video ID in path"""
    return stream_music(video_id)

@app.get("/health")
def health_check():
    """Health check endpoint"""
    return {"status": "healthy", "message": "Music API is running"}

@app.get("/")
def root():
    """API information"""
    return {
        "name": "YouTube Music Search API",
        "version": "1.0.0",
        "endpoints": {
            "search": "/search?query=song+name&offset=0&batch_size=10",
            "stream": "/stream?video_id=VIDEO_ID",
            "stream_alt": "/stream/VIDEO_ID",
            "health": "/health"
        },
        "description": "Fast YouTube music search and streaming API using yt-dlp"
    }


if __name__ == "__main__":
    uvicorn.run("test:app", host="0.0.0.0", port=8000, reload=True)